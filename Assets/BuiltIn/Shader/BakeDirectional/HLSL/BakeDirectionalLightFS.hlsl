// File Generated by Assets/BuildShader.py - source: [BakeDirectionalLightFS.d.hlsl : _]
Texture2D uShadowMap : register(t0);
SamplerState uShadowMapSampler : register(s0);
struct PS_INPUT
{
	float4 pos : SV_POSITION;
	float3 worldNormal: WORLDNORMAL;
	float3 worldPosition: WORLDPOSITION;
	float3 tex0 : LIGHTMAP;
};
cbuffer cbPerFrame
{
	float4 uLightColor;
	float4 uLightDirection;
	float4x4 uShadowMatrix;
};
float shadowSimple(const float4 shadowCoord)
{
	int id = 0;
	float visible = 1.0;
	const float bias = 0.0001;
	float depth = 0.0;
	float result = 0.0;
	float3 shadowUV = shadowCoord.xyz / shadowCoord.w;
	depth = shadowUV.z;
	depth -= bias;
	float2 uv = shadowUV.xy;
	float size = 1.0/2048;
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(-1, -1) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(0, -1) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(1, -1) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(-1, 0) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(0, 0) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(1, 0) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(-1, 1) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(0, 1) * size, 0).r));
	result += (step(depth, uShadowMap.SampleLevel(uShadowMapSampler, uv + float2(1, 1) * size, 0).r));
	return result / 9.0;
}
float4 main(PS_INPUT input) : SV_TARGET
{
	float4 shadowCoord = mul(float4(input.worldPosition, 1.0), uShadowMatrix);
	float visibility = shadowSimple(shadowCoord);
	float NdotL = max(dot(input.worldNormal, uLightDirection.xyz), 0.0);
	float4 directionalLightColor = NdotL * uLightColor / 3.0;
	return float4(directionalLightColor.rgb * visibility, 1.0);
}
