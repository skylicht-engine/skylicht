// File Generated by Assets/BuildShader.py - source: [ToonFS.d.hlsl : SHADOW]
Texture2D uTexDiffuse : register(t0);
SamplerState uTexDiffuseSampler : register(s0);
Texture2D uTexRamp : register(t1);
SamplerState uTexRampSampler : register(s1);
Texture2DArray uShadowMap : register(t2);
SamplerState uShadowMapSampler : register(s2);
struct PS_INPUT
{
	float4 pos : SV_POSITION;
	float2 tex0 : TEXCOORD0;
	float3 worldNormal: WORLDNORMAL;
	float3 worldViewDir: WORLDVIEWDIR;
	float3 worldPos: WORLDPOSITION;
	float3 depth: DEPTH;
};
cbuffer cbPerFrame
{
	float4 uLightDirection;
	float4 uLightColor;
	float4 uColor;
	float4 uShadowColor;
	float2 uWrapFactor;
	float3 uSpecular;
	float3 uShadowDistance;
	float4x4 uShadowMatrix[3];
};
static const float gamma = 2.2;
static const float invGamma = 1.0 / 2.2;
float3 sRGB(float3 color)
{
	return pow(color, gamma);
}
float3 linearRGB(float3 color)
{
	return pow(color, invGamma);
}
float2 rand(float2 co){
    return float2(frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453), frac(sin(dot(co.yx ,float2(12.9898,78.233))) * 43758.5453)) * 0.00047;
}
float texture2DCompare(float3 uv, float compare) {
	float depth = uShadowMap.SampleLevel(uShadowMapSampler, uv, 0).r;
	return step(compare, depth);
}
float shadow(const float4 shadowCoord[3], const float shadowDistance[3], const float farDistance)
{
	int id = 0;
	float visible = 1.0;
	float bias = 0.0001;
	float depth = 0.0;
	float result = 0.0;
	float size = 2048;
	if (farDistance < shadowDistance[0])
		id = 0;
	else if (farDistance < shadowDistance[1])
		id = 1;
	else if (farDistance < shadowDistance[2])
		id = 2;
	else
		return 1.0;
	float3 shadowUV = shadowCoord[id].xyz / shadowCoord[id].w;
	depth = shadowUV.z;
	float2 uv = shadowUV.xy;
	[unroll]
	for (int x = -1; x <= 1; x++)
	{
		[unroll]
		for (int y = -1; y <= 1; y++)
		{
			float2 off = float2(x, y) / size;
			result += texture2DCompare(float3(uv + off + rand(uv + off), id), depth - bias);
		}
	}
	return result / 9.0;
}
float4 main(PS_INPUT input) : SV_TARGET
{
	float3 diffuseMap = sRGB(uTexDiffuse.Sample(uTexDiffuseSampler, input.tex0).rgb);
	float3 color = sRGB(uColor.rgb);
	float3 shadowColor = sRGB(uShadowColor.rgb);
	float3 lightColor = sRGB(uLightColor.rgb);
	float visibility = 1.0;
	float depth = length(input.depth);
	float4 shadowCoord[3];
	shadowCoord[0] = mul(float4(input.worldPos, 1.0), uShadowMatrix[0]);
	shadowCoord[1] = mul(float4(input.worldPos, 1.0), uShadowMatrix[1]);
	shadowCoord[2] = mul(float4(input.worldPos, 1.0), uShadowMatrix[2]);
	float shadowDistance[3];
	shadowDistance[0] = uShadowDistance.x;
	shadowDistance[1] = uShadowDistance.y;
	shadowDistance[2] = uShadowDistance.z;
	visibility = shadow(shadowCoord, shadowDistance, depth);
	float NdotL = max((dot(input.worldNormal, uLightDirection.xyz) + uWrapFactor.x) / (1.0 + uWrapFactor.x), 0.0);
	float3 rampMap = uTexRamp.Sample(uTexRampSampler, float2(NdotL, NdotL)).rgb;
	float3 ramp = lerp(color, shadowColor, uColor.a * (1.0 - visibility));
	ramp = lerp(ramp, color, rampMap);
	float3 h = normalize(uLightDirection.xyz + input.worldViewDir);
	float NdotH = max(0, dot(input.worldNormal, h));
	float spec = pow(NdotH, uSpecular.x*128.0) * uSpecular.y;
	spec = smoothstep(0.5-uSpecular.z*0.5, 0.5+uSpecular.z*0.5, spec);
	return float4(diffuseMap * lightColor * ramp * (0.5 + visibility * 0.5) + lightColor * spec * visibility, 1.0);
}
